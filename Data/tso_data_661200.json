{"displayName":"Piotr Sarnacki","id":"661200","avatar":"","creationDate":"2011-03-15 18:44:45","website":"http:\/\/piotrsarnacki.com","reputation":"519","questionCount":1,"answerCount":7,"commentCount":1,"acceptedCount":5,"nonacceptedCount":2,"activity":{"2013-12":{"commentCount":1},"2011-03":{"questionCount":1},"2011-11":{"answerCount":3,"acceptedCount":2,"nonacceptedCount":1},"2012-04":{"answerCount":1,"acceptedCount":1},"2012-05":{"answerCount":1,"nonacceptedCount":1},"2013-02":{"answerCount":1,"acceptedCount":1},"2013-07":{"answerCount":1,"acceptedCount":1}},"tags":{"java":{"activity":{"2011-03":{"questionCount":1}},"questionCount":1,"relatedTags":{"jetty":1,"httpclient":1}},"jetty":{"activity":{"2011-03":{"questionCount":1}},"questionCount":1,"relatedTags":{"java":1,"httpclient":1}},"httpclient":{"activity":{"2011-03":{"questionCount":1}},"questionCount":1,"relatedTags":{"java":1,"jetty":1}},"ruby-on-rails":{"activity":{"2011-11":{"answerCount":3,"acceptedCount":2,"nonacceptedCount":1},"2012-04":{"answerCount":1,"acceptedCount":1}},"answerCount":4,"acceptedCount":3,"relatedTags":{"configuration":1,"windows":1,"stream":1,"ruby-on-rails-3":1,"rails-engines":1},"nonacceptedCount":1},"configuration":{"activity":{"2011-11":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ruby-on-rails":1}},"windows":{"activity":{"2011-11":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ruby-on-rails":1,"stream":1}},"stream":{"activity":{"2011-11":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ruby-on-rails":1,"windows":1}},"ruby-on-rails-3":{"activity":{"2012-04":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ruby-on-rails":1,"rails-engines":1}},"rails-engines":{"activity":{"2012-04":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ruby-on-rails":1,"ruby-on-rails-3":1}},"ruby":{"activity":{"2012-05":{"answerCount":1,"nonacceptedCount":1}},"answerCount":1,"nonacceptedCount":1,"relatedTags":{"rubygems":1,"gem":1,"bundler":1,"gemfile":1}},"rubygems":{"activity":{"2012-05":{"answerCount":1,"nonacceptedCount":1}},"answerCount":1,"nonacceptedCount":1,"relatedTags":{"ruby":1,"gem":1,"bundler":1,"gemfile":1}},"gem":{"activity":{"2012-05":{"answerCount":1,"nonacceptedCount":1}},"answerCount":1,"nonacceptedCount":1,"relatedTags":{"ruby":1,"rubygems":1,"bundler":1,"gemfile":1}},"bundler":{"activity":{"2012-05":{"answerCount":1,"nonacceptedCount":1}},"answerCount":1,"nonacceptedCount":1,"relatedTags":{"ruby":1,"rubygems":1,"gem":1,"gemfile":1}},"gemfile":{"activity":{"2012-05":{"answerCount":1,"nonacceptedCount":1}},"answerCount":1,"nonacceptedCount":1,"relatedTags":{"ruby":1,"rubygems":1,"gem":1,"bundler":1}},"ember.js":{"activity":{"2013-02":{"answerCount":1,"acceptedCount":1},"2013-07":{"answerCount":1,"acceptedCount":1}},"answerCount":2,"acceptedCount":2,"relatedTags":{"ember-router":1,"javascript":1,"model-view-controller":1,"javascript-framework":1,"ember-data":1}},"ember-router":{"activity":{"2013-02":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"ember.js":1}},"javascript":{"activity":{"2013-07":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"model-view-controller":1,"ember.js":1,"javascript-framework":1,"ember-data":1}},"model-view-controller":{"activity":{"2013-07":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"javascript":1,"ember.js":1,"javascript-framework":1,"ember-data":1}},"javascript-framework":{"activity":{"2013-07":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"javascript":1,"model-view-controller":1,"ember.js":1,"ember-data":1}},"ember-data":{"activity":{"2013-07":{"answerCount":1,"acceptedCount":1}},"answerCount":1,"acceptedCount":1,"relatedTags":{"javascript":1,"model-view-controller":1,"ember.js":1,"javascript-framework":1}}},"questions":{"5317140":{"id":"5317140","date":"2011-03","score":"1","body":"\"<p>I use Jetty HttpClient to send POST request with body around few MB. I want Jetty to start streaming the request as soon as possible, so I use <a href=\\\"http:\\\/\\\/download.eclipse.org\\\/jetty\\\/stable-7\\\/apidocs\\\/org\\\/eclipse\\\/jetty\\\/client\\\/HttpExchange.html#setRequestContentSource(java.io.InputStream)\\\" rel=\\\"nofollow\\\">setRequestContentSource<\\\/a> method.<\\\/p>\\n\\n<p>The problem is that when I use any input stream with available() method returning relatively small value (like 4096) Jetty sometimes crash with following error:<\\\/p>\\n\\n<pre><code>\\norg.eclipse.jetty.io.EofException\\n    at org.eclipse.jetty.http.HttpGenerator.flushBuffer(HttpGenerator.java:911)\\n    at org.eclipse.jetty.client.HttpConnection.handle(HttpConnection.java:241)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:520)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:40)\\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:528)\\n    at java.lang.Thread.run(Thread.java:680)\\nCaused by: \\njava.io.IOException: Broken pipe\\n    at sun.nio.ch.FileDispatcher.write0(Native Method)\\n    at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:29)\\n    at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:100)\\n    at sun.nio.ch.IOUtil.write(IOUtil.java:71)\\n    at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:334)\\n    at org.eclipse.jetty.io.nio.ChannelEndPoint.flush(ChannelEndPoint.java:195)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint.flush(SelectChannelEndPoint.java:285)\\n    at org.eclipse.jetty.io.nio.ChannelEndPoint.flush(ChannelEndPoint.java:316)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint.flush(SelectChannelEndPoint.java:267)\\n    at org.eclipse.jetty.http.HttpGenerator.flushBuffer(HttpGenerator.java:846)\\n    at org.eclipse.jetty.client.HttpConnection.handle(HttpConnection.java:241)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:520)\\n    at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:40)\\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:528)\\n    at java.lang.Thread.run(Thread.java:680)\\n<\\\/code><\\\/pre>\\n\\n<p>It's non deterministic and it seems that putting Thread.sleep(10) in stream's read() method fixes the problem. This error can be also fixed when piped streams are used. Those 3 things make me think that this is some kind of race condition.<\\\/p>\\n\\n<p>I suppose that this is bug in Jetty, but I want to be sure if I'm not doing anything weird in such scenario.<\\\/p>\\n\"","title":"\"Jetty HttpClient creashes on POST when using streams with available() method returning relatively small values\"","favorite":null,"tags":"<java><jetty><httpclient>","commentCount":"0","viewCount":"984","answerCount":"1"}},"answers":{"8330641":{"id":"8330641","date":"2011-11","score":"1","body":"\"<p>You should just use ActionMailer::Base class. The point of using Rails.configuration is to be able to set various options before actual code is loaded. If you need to change something afterwards, there is no need to use Rails.configuration.<\\\/p>\\n\"","title":"\"\"","favorite":null,"tags":"<ruby-on-rails><configuration>","commentcount":"0","accepted":"yes"},"8330679":{"id":"8330679","date":"2011-11","score":"1","body":"\"<p>You need to also include <code>include ActionController::ImplicitRender<\\\/code>. It renders default view if response body was not rendered yet: <a href=\\\"https:\\\/\\\/github.com\\\/rails\\\/rails\\\/blob\\\/5b2eb64ceb08cd005dc06b721935de5853971473\\\/actionpack\\\/lib\\\/action_controller\\\/metal\\\/implicit_render.rb#L5\\\" rel=\\\"nofollow\\\">https:\\\/\\\/github.com\\\/rails\\\/rails\\\/blob\\\/5b2eb64ceb08cd005dc06b721935de5853971473\\\/actionpack\\\/lib\\\/action_controller\\\/metal\\\/implicit_render.rb#L5<\\\/a><\\\/p>\\n\"","title":"\"\"","favorite":null,"tags":"<ruby-on-rails>","commentcount":"0","accepted":""},"8330771":{"id":"8330771","date":"2011-11","score":"0","body":"\"<p>It will be hard with most of the servers, as you mentioned some of them has limited support, so jruby may be your best option. <a href=\\\"https:\\\/\\\/github.com\\\/strobecorp\\\/kirk\\\" rel=\\\"nofollow\\\" title=\\\"Kirk server\\\">Kirk<\\\/a> may be good option for you. It's easy to use jruby wrapper for jetty. It supports both request and response streaming.<\\\/p>\\n\"","title":"\"\"","favorite":null,"tags":"<ruby-on-rails><windows><stream>","commentcount":"0","accepted":"yes"},"10200271":{"id":"10200271","date":"2012-04","score":"11","body":"\"<p>I've debugged the problem and actually it's not a bug in Engines. The problem is caused by the way rails dependencies are loaded.<\\\/p>\\n\\n<p>This code will behave differently in 2 scenarios that you're showing:<\\\/p>\\n\\n<pre><code>module Enginedemo\\n  class DashboardController &lt; ApplicationController\\n  end\\nend\\n<\\\/code><\\\/pre>\\n\\n<p>If <code>ApplicationController<\\\/code> is already loaded, rails will assume that we just want to use it and you will actually not inherit from <code>Enginedemo::ApplicationController<\\\/code> but from <code>ApplicationController<\\\/code>. In the other scenario, when you first load engine's controller, <code>ApplicationController<\\\/code> is not loaded yet, so Rails does the right thing.<\\\/p>\\n\\n<p>Thankfully this problem occurs only in development environment as in production controllers are loaded when application is booting.<\\\/p>\\n\\n<p>I'm not sure if this is something that can be easily fixed in rails dependencies, I will take a look at it.<\\\/p>\\n\\n<p>For now, please explicitly require application controller:<\\\/p>\\n\\n<pre><code>require 'enginedemo\\\/application_controller'\\n\\nmodule Enginedemo\\n  class DashboardController &lt; ApplicationController\\n  end\\nend\\n<\\\/code><\\\/pre>\\n\"","title":"\"\"","favorite":null,"tags":"<ruby-on-rails><ruby-on-rails-3><rails-engines>","commentcount":"1","accepted":"yes"},"10403157":{"id":"10403157","date":"2012-05","score":"6","body":"\"<p>There is a new feature that allows to do that, by simply specyfing <code>local.gem_name<\\\/code> config option, like:<\\\/p>\\n\\n<pre><code>bundle config local.rack ~\\\/path\\\/to\\\/local\\\/rack\\n<\\\/code><\\\/pre>\\n\\n<p>This only works if the gem has a git repo and branch specified in the Gemfile.<\\\/p>\\n\\n<p>See thr Bundler docs for more details: <a href=\\\"http:\\\/\\\/bundler.io\\\/v1.3\\\/bundle_config.html\\\" rel=\\\"nofollow\\\">http:\\\/\\\/bundler.io\\\/v1.3\\\/bundle_config.html<\\\/a><\\\/p>\\n\"","title":"\"\"","favorite":null,"tags":"<ruby><rubygems><gem><bundler><gemfile>","commentcount":"0","accepted":""},"14982829":{"id":"14982829","date":"2013-02","score":"4","body":"\"<p>I'm in the middle of rewriting <a href=\\\"https:\\\/\\\/travis-ci.org\\\" rel=\\\"nofollow\\\">Travis CI<\\\/a> to the newest ember version and I faced the same problem - we fetch repositories by slug (e.g. <code>emberjs\\\/ember.js<\\\/code>), which is not the primary key. My solution involves using <code>Ember.ProxyObject<\\\/code>.<\\\/p>\\n\\n<p>When someone enters the path like <code>\\\/emberjs\\\/ember.js<\\\/code>, the params will look like:<\\\/p>\\n\\n<pre><code>{ owner: 'emberjs', name: 'ember.js` }\\n<\\\/code><\\\/pre>\\n\\n<p>and thus slug will equal <code>emberjs\\\/ember.js<\\\/code>.<\\\/p>\\n\\n<p>With such information, I create simple Ember object, which just keeps <code>slug<\\\/code> and <code>isLoaded<\\\/code> properties:<\\\/p>\\n\\n<pre><code>content = Ember.Object.create slug: slug, isLoaded: false\\n<\\\/code><\\\/pre>\\n\\n<p>Then I create a proxy with this object as the content:<\\\/p>\\n\\n<p>proxy = Ember.ObjectProxy.create(content: content)<\\\/p>\\n\\n<p>Now I can load the record from the server using slug and return the proxy as the model. When I get the record from the server, I simply set proxies content to the actual record.<\\\/p>\\n\\n<p>Full solution is here:<\\\/p>\\n\\n<pre><code>deserialize: (params) -&gt;\\n  slug = \\\"#{params.owner}\\\/#{params.name}\\\"\\n  content = Ember.Object.create slug: slug, isLoaded: false\\n  proxy = Ember.ObjectProxy.create(content: content)\\n\\n  repos = Travis.Repo.bySlug(slug)\\n\\n  observer = -&gt;\\n    if repos.get 'isLoaded'\\n      repos.removeObserver 'isLoaded', observer\\n      proxy.set 'content', repos.objectAt(0)\\n\\n  if repos.length\\n    proxy.set('content', repos[0])\\n  else\\n    repos.addObserver 'isLoaded', observer\\n\\n  proxy\\n<\\\/code><\\\/pre>\\n\\n<p>You can also take a look at the rest of the code <a href=\\\"https:\\\/\\\/github.com\\\/travis-ci\\\/travis-web\\\/blob\\\/5245b7f\\\/assets\\\/scripts\\\/app\\\/routes.coffee#L472-L489\\\" rel=\\\"nofollow\\\">on github<\\\/a><\\\/p>\\n\"","title":"\"\"","favorite":null,"tags":"<ember.js><ember-router>","commentcount":"0","accepted":"yes"},"17517174":{"id":"17517174","date":"2013-07","score":"1","body":"\"<p>You mixed 2 things here: bindings are not the same as observers. You can't bind to something.@each.name, you need to bind to the array and observe on @each. Binding is a connection between 2 values and @each is not really a value, it's a special syntax to tell observers (or computed property dependencies) that you would like to depend on a property on each of the elements in collection.<\\\/p>\\n\\n<p>The other problem is that if you add an observer after a value is set, it will not fire, because the value is already set (ie. there is no change). In your example App.Person.find(1) returns object immediately and person.children does the same - it returns array immediately, which will be later filled with data. So at the point when you run addObserver, children is already set, only its contents will going to be changes (this is why the length observer fires properly).<\\\/p>\\n\\n<p>Here is the fiddle with a few changes: <a href=\\\"http:\\\/\\\/jsfiddle.net\\\/drogus\\\/6EVty\\\/1\\\/\\\" rel=\\\"nofollow\\\">http:\\\/\\\/jsfiddle.net\\\/drogus\\\/6EVty\\\/1\\\/<\\\/a> (I added observerPath and set person after view is inserted), the code:<\\\/p>\\n\\n<pre><code>&lt;script type=\\\"text\\\/x-handlebars\\\" data-template-name=\\\"main\\\"&gt;\\n    {{view App.SubView identifier=\\\"A\\\" modelDataBinding=\\\"view.person.first\\\"}}\\n    {{view App.SubView identifier=\\\"B\\\" modelDataBinding=\\\"view.person.children\\\"}}\\n    {{view App.SubView identifier=\\\"C\\\" modelDataBinding=\\\"view.person.children\\\" observePath=\\\"modelData.@each.name\\\"}}\\n    {{view App.SubView identifier=\\\"D\\\" modelDataBinding=\\\"view.person.children.length\\\"}}\\n&lt;\\\/script&gt;\\n<\\\/code><\\\/pre>\\n\\n<p>And the view class:<\\\/p>\\n\\n<pre><code>SubView: Ember.View.extend({\\n    init: function( ) {\\n        this._super();\\n        var observePath = this.get('observePath') || 'modelData';\\n        this.addObserver( observePath, this, function( ) {\\n            document.write( 'trigger ' + this.get( 'identifier' ) + ': ', this.get( 'modelData' ), '&lt;br \\\/&gt;');\\n        });\\n    }\\n})\\n<\\\/code><\\\/pre>\\n\"","title":"\"\"","favorite":null,"tags":"<javascript><model-view-controller><ember.js><javascript-framework><ember-data>","commentcount":"1","accepted":"yes"}},"comments":{"31218778":{"date":"2013-12","id":"31218778","postid":"5233847","body":"\"Factories are not a holy grail of preparing data for tests. Both solutions have their uses.\"","score":"0","tags":""}}}